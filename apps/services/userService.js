const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const nodemailer = require("nodemailer");
const config = require("../config/setting.json");
const { getGoogleUser } = require("../util/googleAuth");
const { getFacebookAccessToken, getFacebookUser } = require("../util/facebookAuth");
const { UserRepository } = require("./../repositories");

class UserService {
    constructor() {
        this.userRepository = new UserRepository();
        this.verificationCodes = {};
        this.transporter = nodemailer.createTransport({
            service: "gmail",
            auth: { user: config.email.user, pass: config.email.pass },
        });
    }

    async getUserList(page = 1, limit = 3, role = "") {
        const skip = (page - 1) * limit;
        const filter = {};
        if (role) filter.role = role;
        const { users, total } = await this.userRepository.findAll(filter, skip, limit);
        return { users, totalUsers: total };
    }

    async getUser(id) {
        return await this.userRepository.findById(id);
    }

    async getUserByEmail(email) {
        return await this.userRepository.findByEmail(email);
    }

    async updatePassword(userId, hashedNewPassword) {
        return await this.userRepository.updatePassword(userId, hashedNewPassword);
    }

    async insertUser(user) {
        return await this.userRepository.insert(user);
    }

    async updateUser(user) {
        const { _id, ...updateFields } = user;
        return await this.userRepository.update(_id, updateFields);
    }

    async deleteUser(id) {
        return await this.userRepository.delete(id);
    }

    async register(username, email, password, confirmPassword, role = "user") {
        if (password !== confirmPassword) throw new Error("Passwords do not match.");
        const hashedPassword = await bcrypt.hash(password, 10);
        const user = { username, email, password: hashedPassword, role, active: "active" };
        await this.userRepository.insert(user);
        return { message: "ƒêƒÉng k√Ω th√†nh c√¥ng !!" };
    }

    async login(email, password) {
        const user = await this.userRepository.findByEmail(email);
        if (!user)
            throw new Error("Email ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng !!");
        const passwordIsValid = await bcrypt.compare(password, user.password);
        if (!passwordIsValid)
            throw new Error("Email ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng !!");
        if (user.active == "locked")
            throw new Error("T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã kh√≥a. Vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã vi√™n ƒë·ªÉ h·ªó tr·ª£ !!");
        const token = jwt.sign(
            { id: user._id, role: user.role, username: user.username },
            config.jwt.secret,
            { expiresIn: "1h" }
        );
        return { token, role: user.role };
    }

    async loginWithGoogle(code) {
        const googleUser = await getGoogleUser(code);
        const { email, name } = googleUser;
        let user = await this.userRepository.findByEmail(email);
        if (!user) {
            const tempPassword = Math.random().toString(36).slice(-8);
            const hashedPassword = await bcrypt.hash(tempPassword, 10);
            await this.userRepository.insert({
                username: name || email.split("@")[0],
                password: hashedPassword,
                email,
                role: "user",
                active: "active",
            });
            const mailOptions = {
                from: config.email.user,
                to: email,
                subject: "üîë M·∫≠t kh·∫©u t·∫°m th·ªùi t·ª´ EasyTalk",
                html: `
                    <p>Xin ch√†o <strong>${name || email.split("@")[0]}</strong>,</p>
                    <p>B·∫°n v·ª´a ƒëƒÉng k√Ω t√†i kho·∫£n b·∫±ng Google tr√™n EasyTalk.</p>
                    <p>ƒê√¢y l√† m·∫≠t kh·∫©u t·∫°m th·ªùi ƒë·ªÉ b·∫°n c√≥ th·ªÉ ƒëƒÉng nh·∫≠p b·∫±ng email n·∫øu mu·ªën:</p>
                    <h3 style="color:#4CAF50;">${tempPassword}</h3>
                    <p>V√¨ l√Ω do b·∫£o m·∫≠t, b·∫°n n√™n ƒë·ªïi m·∫≠t kh·∫©u sau khi ƒëƒÉng nh·∫≠p.</p>
                    <br/>
                    <p>Tr√¢n tr·ªçng,<br>Nh√≥m h·ªó tr·ª£ EasyTalk</p>
                `,
            };
            this.transporter.sendMail(mailOptions, (error) => {
                if (error) console.error("G·ª≠i email th·∫•t b·∫°i:", error);
                else console.log(`‚úÖ ƒê√£ g·ª≠i m·∫≠t kh·∫©u t·∫°m th·ªùi ƒë·∫øn ${email}`);
            });
            user = await this.userRepository.findByEmail(email);
        }
        if (user.active == "locked") {
            throw new Error("T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã kh√≥a. Vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã vi√™n ƒë·ªÉ h·ªó tr·ª£!");
        }
        const token = jwt.sign(
            { id: user._id, username: user.username, email: user.email, role: user.role },
            config.jwt.secret,
            { expiresIn: "1h" }
        );
        return { token, role: user.role };
    }

    async loginWithFacebook(code) {
        const tokenData = await getFacebookAccessToken(code);
        const accessToken = tokenData.access_token;
        const fbUser = await getFacebookUser(accessToken);
        const { email, name, id: facebookId } = fbUser;
        const userEmail = email || `facebook-${facebookId}@easytalk.com`;
        let user = await this.userRepository.findByEmail(userEmail);
        if (!user) {
            const tempPassword = Math.random().toString(36).slice(-8);
            const hashedPassword = await bcrypt.hash(tempPassword, 10);
            await this.userRepository.insert({
                username: name || userEmail.split("@")[0],
                password: hashedPassword,
                email: userEmail,
                role: "user",
                active: "active",
                facebookId,
            });
            const mailOptions = {
                from: config.email.user,
                to: userEmail,
                subject: "üîë M·∫≠t kh·∫©u t·∫°m th·ªùi t·ª´ EasyTalk",
                html: `
                    <p>Xin ch√†o <strong>${name || userEmail.split("@")[0]}</strong>,</p>
                    <p>B·∫°n v·ª´a ƒëƒÉng k√Ω t√†i kho·∫£n b·∫±ng Facebook tr√™n EasyTalk.</p>
                    <p>ƒê√¢y l√† m·∫≠t kh·∫©u t·∫°m th·ªùi ƒë·ªÉ b·∫°n c√≥ th·ªÉ ƒëƒÉng nh·∫≠p b·∫±ng email n·∫øu mu·ªën:</p>
                    <h3 style="color:#4CAF50;">${tempPassword}</h3>
                    <p>V√¨ l√Ω do b·∫£o m·∫≠t, b·∫°n n√™n ƒë·ªïi m·∫≠t kh·∫©u sau khi ƒëƒÉng nh·∫≠p.</p>
                    <br/>
                    <p>Tr√¢n tr·ªçng,<br>Nh√≥m h·ªó tr·ª£ EasyTalk</p>
                `,
            };
            this.transporter.sendMail(mailOptions, (error) => {
                if (error) console.error("G·ª≠i email th·∫•t b·∫°i:", error);
                else console.log(`‚úÖ ƒê√£ g·ª≠i m·∫≠t kh·∫©u t·∫°m th·ªùi ƒë·∫øn ${userEmail}`);
            });
            user = await this.userRepository.findByEmail(userEmail);
        }
        if (user.active == "locked") {
            throw new Error("T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã kh√≥a. Vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã vi√™n ƒë·ªÉ h·ªó tr·ª£!");
        }
        const token = jwt.sign(
            { id: user._id, username: user.username, email: user.email, role: user.role },
            config.jwt.secret,
            { expiresIn: "1h" }
        );
        return { token, role: user.role };
    }

    async changePassword(userId, currentPassword, newPassword, confirmNewPassword) {
        if (!currentPassword || !newPassword || !confirmNewPassword)
            throw new Error("Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin m·∫≠t kh·∫©u.");
        if (newPassword !== confirmNewPassword)
            throw new Error("M·∫≠t kh·∫©u m·ªõi kh√¥ng kh·ªõp.");
        const user = await this.userRepository.findById(userId);
        if (!user)
            throw new Error("Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng.");
        const passwordIsValid = await bcrypt.compare(currentPassword, user.password);
        if (!passwordIsValid)
            throw new Error("M·∫≠t kh·∫©u hi·ªán t·∫°i kh√¥ng ch√≠nh x√°c.");
        const hashedNewPassword = await bcrypt.hash(newPassword, 10);
        await this.userRepository.updatePassword(userId, hashedNewPassword);
        return { message: "ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng." };
    }

    async sendForgotPasswordCode(email) {
        const user = await this.userRepository.findByEmail(email);
        if (!user)
            throw new Error("Email ƒë√£ nh·∫≠p kh√¥ng t·ªìn t·∫°i tr√™n h·ªá th·ªëng !!");
        const verificationCode = Math.floor(10000 + Math.random() * 90000);
        const expiresAt = Date.now() + 60 * 1000;
        this.verificationCodes[email] = { code: verificationCode, expiresAt };
        const mailOptions = {
            from: config.email.user,
            to: email,
            subject: "Th√¥ng B√°o M√£ X√°c Th·ª±c ƒê·∫∑t L·∫°i M·∫≠t Kh·∫©u T·ª´ EasyTalk",
            html: `<p>Xin ch√†o,</p>
            <p>Ch√∫ng t√¥i ƒë√£ nh·∫≠n ƒë∆∞·ª£c y√™u c·∫ßu ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u c·ªßa b·∫°n. Vui l√≤ng s·ª≠ d·ª•ng m√£ x√°c minh b√™n d∆∞·ªõi ƒë·ªÉ ti·∫øn h√†nh ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u c·ªßa b·∫°n. M√£ n√†y c√≥ hi·ªáu l·ª±c trong <strong>1 ph√∫t</strong>.</p>
            <h2 style="color: #4CAF50;">${verificationCode}</h2>
            <p>N·∫øu b·∫°n kh√¥ng y√™u c·∫ßu ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u, vui l√≤ng b·ªè qua email n√†y ho·∫∑c <a href="pductai14@gmail.com">li√™n h·ªá v·ªõi b·ªô ph·∫≠n h·ªó tr·ª£</a> n·∫øu b·∫°n c√≥ b·∫•t k·ª≥ th·∫Øc m·∫Øc n√†o.</p>
            <p>Tr√¢n tr·ªçng,</p>
            <p>Nh√≥m h·ªó tr·ª£ EasyTalk</p>`,
        };

        await this.transporter.sendMail(mailOptions);
        return { success: true, message: "M√£ x√°c th·ª±c ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email c·ªßa b·∫°n!", expiresAt, serverTime: Date.now() };
    }

    verifyForgotPasswordCode(email, code) {
        const record = this.verificationCodes[email];
        if (!record)
            throw new Error("M√£ x√°c th·ª±c ƒë√£ h·∫øt h·∫°n ho·∫∑c kh√¥ng t·ªìn t·∫°i!");
        if (Date.now() > record.expiresAt) {
            delete this.verificationCodes[email];
            throw new Error("M√£ x√°c th·ª±c ƒë√£ h·∫øt h·∫°n, vui l√≤ng g·ª≠i l·∫°i m√£ m·ªõi!");
        }
        if (String(record.code) !== String(code))
            throw new Error("M√£ x√°c th·ª±c kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p ch√≠nh x√°c!");

        delete this.verificationCodes[email];
        return { success: true, message: "M√£ x√°c th·ª±c ch√≠nh x√°c!" };
    }

    async resetPassword(email, newPassword) {
        const user = await this.userRepository.findByEmail(email);
        if (!user)
            throw new Error("User not found");
        const hashedPassword = await bcrypt.hash(newPassword, 10);
        await this.userRepository.updatePassword(user._id, hashedPassword);
        return { message: "Password reset successful" };
    }

    async updateProfile(userId, username, email) {
        const updatedUser = await this.userRepository.update(userId, { username, email });
        if (!updatedUser)
            throw new Error("Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng !");
        return { success: true, message: "Th√¥ng tin c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng !", user: updatedUser };
    }

    async getUserById(userId) {
        return await this.userRepository.findById(userId);
    }
}

module.exports = UserService;